use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion, Throughput};
use gcode_language_server::{parse_line, validate_document, FlavorRegistry};

/// Generate G-code documents of different sizes for LSP benchmarking
fn generate_document(lines: usize, pattern: &str) -> String {
    let mut content = String::new();

    match pattern {
        "typical_print" => {
            // Simulate a typical 3D print file
            content.push_str("; Generated by PrusaSlicer\n");
            content.push_str("G28 ; Home all axes\n");
            content.push_str("G90 ; Absolute positioning\n");
            content.push_str("M104 S210 ; Set hotend temperature\n");
            content.push_str("M140 S60 ; Set bed temperature\n");

            for i in 0..lines {
                let layer = i / 100;
                if i % 100 == 0 {
                    content.push_str(&format!("; LAYER:{}\n", layer));
                }
                content.push_str(&format!(
                    "G1 X{:.3} Y{:.3} Z{:.3} E{:.5} F1500\n",
                    (i as f32) * 0.1,
                    (i as f32) * 0.1,
                    layer as f32 * 0.2,
                    (i as f32) * 0.02
                ));
            }
        }
        "complex_features" => {
            for i in 0..lines {
                match i % 10 {
                    0 => content.push_str(&format!(
                        "G1 X{:.3} Y{:.3} F1500\n",
                        (i as f32) * 0.1,
                        (i as f32) * 0.1
                    )),
                    1 => content.push_str(&format!("M104 S{}\n", 200 + (i % 50))),
                    2 => content.push_str(&format!("M140 S{}\n", 60 + (i % 20))),
                    3 => content.push_str(&format!("G0 Z{:.2}\n", (i as f32) * 0.1)),
                    4 => content.push_str(&format!("M106 S{}\n", i % 255)),
                    5 => content.push_str(&format!("; Comment line {}\n", i)),
                    6 => content.push_str(&format!(
                        "G2 X{:.2} Y{:.2} I{:.2} J{:.2}\n",
                        (i as f32) * 0.1,
                        (i as f32) * 0.1,
                        5.0,
                        5.0
                    )),
                    7 => content.push_str(&format!("M851 Z{:.3}\n", (i as f32) * 0.001)),
                    8 => content.push_str(&format!("G29 ; Bed leveling {}\n", i)),
                    9 => content.push_str(&format!("M900 K{:.2}\n", (i as f32) * 0.01)),
                    _ => unreachable!(),
                }
            }
        }
        _ => {
            for i in 0..lines {
                content.push_str(&format!("G1 X{} Y{}\n", i, i));
            }
        }
    }

    content
}

/// Benchmark validation performance with different file sizes
fn bench_validation_performance(c: &mut Criterion) {
    let mut registry = FlavorRegistry::new();
    registry.add_embedded_prusa_flavor();

    let file_sizes = vec![100, 1_000, 10_000, 50_000];
    let patterns = vec!["typical_print", "complex_features"];

    let mut group = c.benchmark_group("validation_performance");

    for &size in &file_sizes {
        for pattern in &patterns {
            let content = generate_document(size, pattern);

            group.throughput(Throughput::Elements(size as u64));
            group.bench_with_input(
                BenchmarkId::new(format!("validate_{}_{}", pattern, size), size),
                &content,
                |b, content| {
                    b.iter(|| {
                        let result = validate_document(black_box(content), black_box(&registry));
                        black_box(result)
                    })
                },
            );
        }
    }

    group.finish();
}

/// Benchmark parsing + validation pipeline
fn bench_full_pipeline(c: &mut Criterion) {
    let mut registry = FlavorRegistry::new();
    registry.add_embedded_prusa_flavor();

    let file_sizes = vec![1_000, 10_000, 50_000];

    let mut group = c.benchmark_group("full_pipeline");

    for &size in &file_sizes {
        let content = generate_document(size, "typical_print");
        let byte_size = content.len();

        group.throughput(Throughput::Bytes(byte_size as u64));
        group.bench_with_input(
            BenchmarkId::new("parse_and_validate", size),
            &content,
            |b, content| {
                b.iter(|| {
                    let lines: Vec<&str> = content.lines().collect();

                    // Parse all lines
                    let parsed: Vec<_> = lines.iter().map(|line| parse_line(line)).collect();

                    // Validate document
                    let diagnostics = validate_document(content, &registry);

                    black_box((parsed, diagnostics))
                })
            },
        );
    }

    group.finish();
}

/// Benchmark validation with different error rates
fn bench_validation_error_scenarios(c: &mut Criterion) {
    let mut registry = FlavorRegistry::new();
    registry.add_embedded_prusa_flavor();

    let mut group = c.benchmark_group("validation_errors");

    // Document with no errors
    let clean_content = (0..1000)
        .map(|i| format!("G1 X{:.3} Y{:.3} F1500", (i as f32) * 0.1, (i as f32) * 0.1))
        .collect::<Vec<_>>()
        .join("\n");

    group.bench_function("no_errors", |b| {
        b.iter(|| {
            let result = validate_document(black_box(&clean_content), black_box(&registry));
            black_box(result)
        })
    });

    // Document with many errors (missing required parameters)
    let error_content = (0..1000)
        .map(|_| "G1".to_string()) // G1 without required coordinates
        .collect::<Vec<_>>()
        .join("\n");

    group.bench_function("many_errors", |b| {
        b.iter(|| {
            let result = validate_document(black_box(&error_content), black_box(&registry));
            black_box(result)
        })
    });

    // Document with mixed errors
    let mixed_content = (0..1000)
        .enumerate()
        .map(|(i, _)| {
            if i % 3 == 0 {
                format!("G1 X{:.3} Y{:.3} F1500", (i as f32) * 0.1, (i as f32) * 0.1)
            // Valid
            } else if i % 3 == 1 {
                "G1".to_string() // Missing parameters
            } else {
                "INVALID_COMMAND".to_string() // Unknown command
            }
        })
        .collect::<Vec<_>>()
        .join("\n");

    group.bench_function("mixed_errors", |b| {
        b.iter(|| {
            let result = validate_document(black_box(&mixed_content), black_box(&registry));
            black_box(result)
        })
    });

    group.finish();
}

/// Benchmark flavor registry operations
fn bench_flavor_operations(c: &mut Criterion) {
    let mut registry = FlavorRegistry::new();
    registry.add_embedded_prusa_flavor();

    let mut group = c.benchmark_group("flavor_operations");

    let commands = vec!["G1", "G28", "M104", "M140", "M106", "G29", "M851", "M900"];

    for command in &commands {
        group.bench_with_input(
            BenchmarkId::new("find_command", command),
            command,
            |b, cmd| {
                b.iter(|| {
                    let result = registry.get_command(black_box(cmd));
                    black_box(result)
                })
            },
        );
    }

    group.finish();
}

/// Benchmark document processing at different positions (simulating LSP requests)
fn bench_position_based_operations(c: &mut Criterion) {
    let content = generate_document(10_000, "typical_print");
    let lines: Vec<&str> = content.lines().collect();

    let mut group = c.benchmark_group("position_operations");

    // Simulate hover requests at different document positions
    let positions = vec![
        ("start", 10),
        ("middle", lines.len() / 2),
        ("end", lines.len() - 10),
    ];

    for (pos_name, line_num) in positions {
        if line_num < lines.len() {
            let line = lines[line_num];

            group.bench_with_input(
                BenchmarkId::new("parse_at_position", pos_name),
                &line,
                |b, line| {
                    b.iter(|| {
                        let parsed = parse_line(black_box(line));
                        black_box(parsed)
                    })
                },
            );
        }
    }

    group.finish();
}

/// Benchmark concurrent parsing (simulating multiple LSP requests)
fn bench_concurrent_operations(c: &mut Criterion) {
    let test_lines = [
        "G1 X10 Y20 F1500",
        "M104 S210",
        "G28",
        "M140 S60",
        "G0 Z5",
        "M106 S255",
        "G29",
        "M851 Z-0.1",
    ];

    let mut group = c.benchmark_group("concurrent_parsing");

    group.bench_function("sequential", |b| {
        b.iter(|| {
            let results: Vec<_> = test_lines
                .iter()
                .map(|line| parse_line(black_box(line)))
                .collect();
            black_box(results)
        })
    });

    // Note: For true concurrent benchmarking, we'd need to use rayon or similar,
    // but this simulates the sequential processing pattern of LSP requests
    group.bench_function("batch_processing", |b| {
        b.iter(|| {
            let results: Vec<_> = test_lines
                .iter()
                .cycle()
                .take(1000)
                .map(|line| parse_line(black_box(line)))
                .collect();
            black_box(results)
        })
    });

    group.finish();
}

criterion_group!(
    lsp_benches,
    bench_validation_performance,
    bench_full_pipeline,
    bench_validation_error_scenarios,
    bench_flavor_operations,
    bench_position_based_operations,
    bench_concurrent_operations
);

criterion_main!(lsp_benches);
